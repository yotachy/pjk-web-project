<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>시인 박종권의 홈페이지</title>
  <meta name="description" content="박종권 시인의 작품과 기록을 이곳에.." />

<link rel="stylesheet" href="./assets/css/style.css?v=20251223-01" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
</head>

<body class="theme-auto">
  <header class="tv-top" role="banner">
    <div class="tv-top__inner">
      <a class="tv-brand" href="#home" aria-label="홈으로">
        <span class="tv-brand__title">환영합니다.</span>
      </a>

      <nav class="tv-nav" aria-label="주요 메뉴">
        <a class="tv-tab is-active" href="#home" data-nav="home" aria-current="page">메인</a>
        <a class="tv-tab" href="#about" data-nav="about">소개</a>
        <a class="tv-tab" href="#works" data-nav="works">작품·활동</a>
      </nav>
    </div>
  </header>

  <main class="tv-page" role="main">
    <section id="home" class="tv-section tv-section--hero" aria-label="메인">
      <div class="tv-hero">
        <div class="tv-hero__inner">
          <div class="tv-left" aria-label="메인 소개">
            <p class="tv-line tv-line--big">말하지 못한 마음들이<br/>가장 낮은 목소리로 남아 있는 곳</p>
            <div class="tv-divider" role="presentation" aria-hidden="true"></div>
            <p class="tv-line tv-line--small">"지나간 마음과 미처 전하지 못한 말들,<br/>그 사이에 머문 풍경을 천천히 기록합니다.<br/>이곳에서 잠시 멈춰도 괜찮습니다."</p>

            <div class="tv-cta">
              <a class="tv-btn" href="#works">주요 작품</a>
              <a class="tv-link" href="#about">시인 "박종권"을 소개합니다</a>
            </div>
          </div>

          <div class="tv-right" aria-label="프로필 비주얼">
            <figure class="tv-panel">
              <img
                id="profileImg"
                class="tv-panel__img"
                src="./assets/img/profile.jpg"
                alt="박종권 프로필 사진"
                loading="eager"
                decoding="async"
                crossorigin="anonymous"
              />
              <figcaption class="tv-panel__cap">PARK JONG KWON</figcaption>
            </figure>
          </div>
        </div>
      </div>
    </section>

    <section id="about" class="tv-section tv-section--blank" aria-label="소개">
      <div class="tv-shell">
        <div class="tv-stage">
          <div class="tv-kicker">INTRODUCTION</div>
          <h2 class="tv-h2">소개</h2>
          <p class="tv-lead">
            이 영역은 한 페이지 정도 여백을 두고, 향후 소개 글·연보·연락처 등을
            추가할 수 있도록 구성했습니다.
          </p>
          <div class="tv-blank" aria-hidden="true"></div>
          <div class="tv-hint" aria-hidden="true">
            스크롤을 내리면 상단 메뉴가 자동으로 따라 선택됩니다.
          </div>
        </div>
      </div>
    </section>

    <section id="works" class="tv-section tv-section--blank" aria-label="작품·활동">
      <div class="tv-shell">
        <div class="tv-stage">
          <div class="tv-kicker">WORKS & ACTIVITY</div>
          <h2 class="tv-h2">작품·활동</h2>
          <p class="tv-lead">
            이 영역도 한 페이지 정도 비워두었습니다.
            대표 시·시집·낭독 기록·활동 로그 등을 이후에 추가하시면 됩니다.
          </p>
          <div class="tv-blank" aria-hidden="true"></div>
          <div class="tv-hint" aria-hidden="true">
            필요 시, 작품 목록을 카드/타임라인 형태로 확장할 수 있습니다.
          </div>
        </div>
      </div>
    </section>

    <footer class="tv-foot" role="contentinfo">
      <div class="tv-foot__inner">
        <span>© <span id="year"></span> Park Jongkwon</span>
        <span class="tv-foot__muted">Poetry • Archive</span>
      </div>
    </footer>
  </main>

  <script>
    document.getElementById("year").textContent = new Date().getFullYear();

    (function applyThemeFromProfile(){
      const img = document.getElementById("profileImg");
      if (!img) return;

      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
      function rgbToHex(r,g,b){
        const h = (v)=>v.toString(16).padStart(2,"0");
        return `#${h(r)}${h(g)}${h(b)}`;
      }
      function luminance(r,g,b){
        const a=[r,g,b].map(v=>{
          v/=255;
          return v<=0.03928 ? v/12.92 : Math.pow((v+0.055)/1.055, 2.4);
        });
        return 0.2126*a[0]+0.7152*a[1]+0.0722*a[2];
      }

      function sampleEdgeColor(image){
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        if (!ctx) return null;

        const w = Math.max(64, Math.min(256, image.naturalWidth || 256));
        const h = Math.max(64, Math.min(256, image.naturalHeight || 256));
        canvas.width = w;
        canvas.height = h;

        try {
          ctx.drawImage(image, 0, 0, w, h);
          const data = ctx.getImageData(0, 0, w, h).data;

          const samples = [];
          const step = Math.max(2, Math.floor(Math.min(w,h) / 32));
          const band = Math.max(2, Math.floor(Math.min(w,h) * 0.12));

          function pushPixel(x,y){
            const i = (y*w + x) * 4;
            const r = data[i], g = data[i+1], b = data[i+2], a = data[i+3];
            if (a < 12) return;
            samples.push([r,g,b]);
          }

          for (let y=0; y<band; y+=step) for (let x=0; x<w; x+=step) pushPixel(x,y);
          for (let y=h-band; y<h; y+=step) for (let x=0; x<w; x+=step) pushPixel(x,y);
          for (let x=0; x<band; x+=step) for (let y=0; y<h; y+=step) pushPixel(x,y);
          for (let x=w-band; x<w; x+=step) for (let y=0; y<h; y+=step) pushPixel(x,y);

          if (!samples.length) return null;

          const rs = samples.map(s=>s[0]).sort((a,b)=>a-b);
          const gs = samples.map(s=>s[1]).sort((a,b)=>a-b);
          const bs = samples.map(s=>s[2]).sort((a,b)=>a-b);

          const lo = Math.floor(samples.length * 0.2);
          const hi = Math.floor(samples.length * 0.8);

          function avg(arr){
            let sum=0, n=0;
            for (let i=lo; i<hi; i++){ sum += arr[i]; n++; }
            return n ? Math.round(sum/n) : Math.round(arr[Math.floor(arr.length/2)]);
          }

          return [avg(rs), avg(gs), avg(bs)];
        } catch(e){
          return null;
        }
      }

      function setVarsFromRGB(r,g,b){
        const bg = rgbToHex(r,g,b);
        const lum = luminance(r,g,b);

        const ink = lum < 0.45 ? "rgba(255,255,255,.92)" : "rgba(18,18,18,.92)";
        const muted = lum < 0.45 ? "rgba(255,255,255,.68)" : "rgba(18,18,18,.62)";
        const hairline = lum < 0.45 ? "rgba(255,255,255,.10)" : "rgba(18,18,18,.10)";

        document.documentElement.style.setProperty("--bg", bg);
        document.documentElement.style.setProperty("--ink", ink);
        document.documentElement.style.setProperty("--muted", muted);
        document.documentElement.style.setProperty("--hairline", hairline);

        const adj = lum < 0.45 ? 18 : -18;
        document.documentElement.style.setProperty("--bg2",
          rgbToHex(clamp(r+adj,0,255), clamp(g+adj,0,255), clamp(b+adj,0,255))
        );

        document.documentElement.style.setProperty("--u", lum < 0.45 ? "rgba(255,255,255,.28)" : "rgba(18,18,18,.22)");
      }

      function run(){
        const rgb = sampleEdgeColor(img);
        if (rgb) setVarsFromRGB(rgb[0], rgb[1], rgb[2]);
        document.body.classList.add("is-themed");
      }

      if (img.complete && img.naturalWidth) run();
      else img.addEventListener("load", run, { once:true });
    })();

    (function scrollSpy(){
      const tabs = Array.from(document.querySelectorAll(".tv-tab[data-nav]"));
      const sections = ["home","about","works"]
        .map(id => document.getElementById(id))
        .filter(Boolean);

      function setActive(id){
        tabs.forEach(a=>{
          const on = a.getAttribute("data-nav") === id;
          a.classList.toggle("is-active", on);
          if (on) a.setAttribute("aria-current","page");
          else a.removeAttribute("aria-current");
        });
      }

      function headerOffset(){
        const h = document.querySelector(".tv-top");
        return Math.max(60, Math.round(h ? h.getBoundingClientRect().height : 96));
      }

      let io = null;
      function bindObserver(){
        const top = headerOffset();
        if (io) io.disconnect();

        io = new IntersectionObserver((entries)=>{
          const visible = entries
            .filter(e => e.isIntersecting)
            .sort((a,b)=> (a.boundingClientRect.top - b.boundingClientRect.top));

          if (visible.length){
            setActive(visible[0].target.id);
          }
        },{
          root: null,
          threshold: [0.18, 0.25, 0.35],
          rootMargin: `-${top + 8}px 0px -55% 0px`
        });

        sections.forEach(sec => io.observe(sec));
      }

      document.addEventListener("click", (e)=>{
        const a = e.target.closest('a[href^="#"]');
        if (!a) return;

        const hash = a.getAttribute("href");
        const target = document.querySelector(hash);
        if (!target) return;

        e.preventDefault();
        const top = headerOffset();
        const y = target.getBoundingClientRect().top + window.scrollY - top - 8;

        window.scrollTo({ top: y, behavior: "smooth" });
        if (target.id) setActive(target.id);
      }, { passive:false });

      bindObserver();

      window.addEventListener("resize", ()=>{
        bindObserver();
      }, { passive:true });
    })();
  </script>
</body>
</html>
